# Nuxt の機能をフル活用する

前セクションにて、 Nuxt の基本的な機能と使い方についてご紹介しましたが、ここからはより実践的な Nuxt の機能を機能単位で一つずつご紹介していきます。

いずれも Vue 単体の開発では頭を悩ませることの多い課題であり、その課題への解決策を
 Nuxt が提示してくれているポイントとなりますので、存分にご活用して効率的なアプリケーション開発に役立てていただけると幸いです。

また、この章に登場するサンプルコードは、全て nuxt-community/starter-template をベースで動かすことで、実際に動作させることが可能となっています。

## layouts によるレイアウトの共通化

Nuxt には、ページごとの共通レイアウトを、Vueコンポーネントとして再利用するレイアウト機能が実装されています。

例えば、「基本的にはナビゲーションやヘッダーを共通化して表示したいけれど、ルートコンポーネント上に定義してしまうとログイン画面やトップページなど、表示したくないページで表示されてしまい不便。とはいえその解決のために下手に `v-if` で分岐すると次はルートのコンポーネントが汚れてしまう。」

といった、共通化したいモチベーションと共通化した場合に管理コストが増大するという問題が共存している場合には、 layouts を利用することで解決が可能です。

その他にも、投稿型システムの単一投稿の表示ページにおいて、レイアウト側で極力UIを定義しておくことで、投稿の本体をクリーンに保ち、単一投稿の表示UIを効率的に使いまわすなど、「特定のUIの形式をテンプレート化したい」という時にも利用でき、非常に便利な機能となります。

### レイアウトのルールと default.vue の編集

それでは実際にレイアウトを利用してみましょう。
Nuxt は、デフォルトのレイアウトとして default.vue を所持しており、特にレイアウト指定がない場合は default.vue が参照される仕様となっております。

今回は試しに、 `components/AppNavigation.vue` というナビゲーションのコンポーネントを作成し、 default.vue から読み込んでみます。

まずは `components/AppNavigation.vue` に、以下のコードを記述してください。

```html:AppNavigation.vue
<tempalte>
  <ul>
    <li><router-link to="/">home</router-link></li>
    <li><router-link to="/child">child</router-link></li>
  </ul>
</template>
```

その上で、 `layouts/default.vue` に以下のように記述してください。

```html:default.vue
<template>
  <div>
    <AppNavigation />
    <nuxt />
  </div>
</template>

<script>
import AppNavigation from '~/components/AppNavigation.vue'

export default {
  components: {
    AppNavigation
  }
}
```

この状態で、ページへとアクセスすると、 `pages/index.vue` には何も書かれていないにもかかわらず、ナビゲーションがレンダリングされることがわかります。

折角なのでナビゲーションにある `pages/child.vue`  を作成して、こちらにもアクセスしてみましょう。 `pages/child.vue` のソースコードは以下のようにしてください。

```html:child.vue
<template>
  <div>
    <h1>Child</h1>
  </div>
</template>
```

この状態で `/child` に作成されても、フォールバックである default.vue が読み込まれていることがわかるかと思います。
このように、レイアウトを設定することで、簡単に共通 UI を作成することが可能です。

### 今見ているページのレイアウトは Vue.js Devtools でも確認可能

また、今見ているページのレイアウトが本当に期待通りかどうかは、 Vue.js Devtools からも確認できます。レイアウトもコンポーネントであるため、 Vue.js Devtools 上で名前がついて表示されます。

ソースコードを追うまでもない程度の場合はこちらも有効活用すると良いでしょう。

### レイアウトファイル設計のベストプラクティス

一見非常なレイアウトシステムですが、多少クセがあるため、最後にラクにレイアウトを管理するためのオススメの方法をご紹介いたします。

starter テンプレートを初期化した時など、基本的には汎用レイアウトとトップページから編集をはじめることが多いかと思いますが、基本的にトップページはLPであったり、ダッシュボードのサマリーページであったり、他のページとは大きく異なるデザインを適用することがほとんどです。

そういったときに、もし default.vue をトップページ用に、それぞれの個別のページを single.vue などとした場合、全てのページコンポーネントに対して `layout: 'single'` を指定する必要があり、適用忘れなどのミスの原因となります。

これを防ぐためにも、 default.vue はアプリケーション全体で使われるレイアウトとし、こちらに single 相当の記述を、トップページのために、専用の home.vue などのレイアウトファイルを作成して、トップページだけ `layout: 'home'` 指定するのが良いでしょう。

こうすることで、トップページは専用の home.vue により完全に隔離された上で、煩雑なレイアウトの設定も行う必要がなくなるため、ミスも減りますし、管理しやすい構成となります。

default.vue は大きなプロジェクトになると使わないほうがわかりやすい場合もありますが、小中規模ではフォールバック先として有効活用しましょう。

## middleware を利用したルーティング結果の改竄

次はミドルウェアです。
サーバーサイドのプログラミングを行ったことがあるかたにはおなじみの、request / responseオブジェクトに対して、そのルーティングの実処理の前後に割り込み、request / responseオブジェクトを改ざんすることができる機能となります。

例えば、この機能を利用することで、「Cookieに格納された認証トークンを確認した上で、正しい認証トークンの場合はVuexのストアに認証情報を追加する機能」や、「日本人が英語ページにきた際に自動で日本語ページへとリダイレクトをする機能」など、Webアプリケーションの開発で頻繁に利用される割り込みを、非常に簡単に実装することが可能となります。

特に、Nuxt では、request / responseオブジェクトの改ざんだけでなく、上述の通りVuexストアへのアクセスや、302リダイレクトの発行などが可能となっているため、非常に柔軟に利用することが可能です。

実際の Cookie 認証のサンプルは次の章で詳しくご紹介します。より実践的な記述についてはそちらをご参照ください。

ここでは特定のパスの場合のみリダイレクトするという簡単なサンプルをもとに、基本的な使い方を網羅する形でご紹介します。

### 最低限のミドルウェア雛形の作成

ミドルウェアは、 `middleware/redirector.js` というかたちで、 middleware 配下に作成します。

```js:redirector.js
export default function ({ redirect, route }) {
  if (route.path == '/users/2') redirect('/')
}
```

その上で、グローバルで使う middleware は、 nuxt.config.js に追記します。

```js:nuxt.config.js
module.exports = {
// ...
  router: {
    middleware: ['auth']
  }
// ...
}
```

また、ページコンポーネントに直接記述すると、そのページコンポーネントにアクセスされる時限定のミドルウェアを作成することも可能です。

例えば、 `pages/users/_id.vue` だけに以下のような記述を加えると、 `middleware/redirector.js` 側で path を参照せずとも、 `users` 配下である前提で処理を記述することが可能です。

```html:_id.vue
<script>
export default {
  middleware: 'redirector'
}
</script>
```

### ミドルウェアの注意点

最後に、非常に強力な機能であるミドルウェアですが、2つほど注意点があるためご紹介します。

#### SSR 前提という原則と fetch フック

ミドルウェアは、requestオブジェクトへのアクセスを必要とする場合があるという都合上、SPAモードでは動作しません。SSRモードにおいても、初期アクセス時のみ有効な機能となっており、SPAモードに一旦移行してしまった場合、ミドルウェアは機能を失います。

#### SSR によるレイテンシ

また、勿論ですが、ミドルウェアの実行はサーバー側の作業の一環となりますので、外部APIへのフェッチなどを行う際は、レスポンス速度に多少なりとも影響があります。

HTTP リクエストの中で、更に HTTP リクエストが発生するということを十分に理解した上で利用すると良いでしょう。

筆者としては、ミドルウェアの利用はルーティングの認証機能の実装程度に留めておくことを強くオススメします。

## plugin によるグローバルな機能拡張

ミドルウェアと似ているようで大きく違う、プラグイン機能についてもご紹介いたします。
このプラグイン機能は、初期ロード時に自動で読み出され、特定の処理を行うというものです。

一見ミドルウェアと同じような仕組みに見えますが、利用用途は全く異なります。ここでは、簡単な例と共に、プラグインについてご紹介します。

### プラグインの使いどころ

プラグインは、ミドルウェアのページの処理の前に挟まるフックではなく、単純にグローバルな機能拡張を行うときに利用します。

前述の通り、ミドルウェアと同じく、初期ロード時に読み出され、処理が実行されますが、ここでルーティングに対する改ざんを行うのではなく、グローバルな Vue ライブラリの import や、 VueRouter のフック登録などに使います。あくまでもリクエスト・レスポンスが主体ものはミドルウェアに、アプリケーションに対してのライブラリ登録など、リクエストやレスポンスの内容に直接関係のないものは、プラグインに実装することとなります。

例えば、グローバルに影響するものであると「Google Analytics」の SPA でのロギングの有効化などがあります。
ここでは、ロギングなどでは必須の、プラグインからの VueRouter フックの登録についてご紹介します。

### プラグインの作成

今回は試しに VueRouter の beforeEach フックを利用して、ページ遷移が行われるたびにそのルーティングパスを console.log で表示するコードを書いてみます。

プラグインのコードは、 plugins ディレクトリ以下に作成する必要があり、ここで作成されたものはプラグインとして利用が可能となります。

まずは `plugins/logger.js` を作成し、以下のように記述してみましょう。

```js:logger.js
/* plugins/logger.js */
export default ({ app }) => {
  app.router.beforeEach((to, from, next) => {
    console.log(`move to "${to.fullPath}`)
    next()
  })
}
```

基本的には VueRouter を直で使う場合と同じく、3 つの引数を受け取った上で、 before の場合は `next()` を実行しますが、その際の Router オブジェクトは app から降ってくることにご注意ください。

app を取得している関数の第一引数は、ミドルウェアや asyncData と同じく、コンテキストを受け取ります。
ここには redirect や Vuex store も格納されているため、適宜読み出すと良いでしょう。

### プラグインの登録と実行

プラグインが実装できたら、 nuxt.config.js を書き換えます。export するオブジェクトに plugins を作成し、以下を追加しましょう。

```js:nuxt.config.js
{
  // ...
  plugins: [ '~/plugins/logger' ]
  // ...
}
```

このように、 plugins というキーで配列を作成することで、ここに登録されたプラグインは初期ロード時に実行されるようになります。

実際に動かしてみると、以下のスクリーンショットのように、ページ遷移のたびに console.log によってパスが表示されていることがわかるかと思います。
Google Analytics や Mixpanel などのトラッキングを実装する必要がある場合は、このように beforeEach や afterEach と組み合わせてやると良いでしょう。

## Vuexのモジュールモードを活用したオートローディング

次に、 Vuex のオートローディングについて説明いたします。
前章でも軽く説明しましたが、ここではより深く、実践的な利用方法についてご紹介いたします。

### Vuexストアへのアクセスの二つのモード

Nuxt の Vuex ストアには **クラシックモード** と **モジュールモード**  という二つのモードがあります。以下に簡単に違いについて説明します。

クラシックモードは、単一の State のみをもつ大きな Vuex ストアをベースに、もしモジュールが必要であれば適宜手動で追加していく、通常の Vue 開発に近いモードです。

モジュールモードは、 Nuxt の store ディレクトリ内にファイルを作成してゆき、 Vuex ストアインスタンスではなく、 state や mutation 、 action などをそれぞれ別にエクスポートすることで、 Nuxt が自動で全てのファイルを名前空間付きのモジュールとして解釈し、 Vuex ストアインスタンスにまとめてくれるモードとなります。

筆者としては、数ページ規模の小規模アプリケーションまではクラシックモードで十分ですが、そういったもの以外ではモジュールモードの利用をオススメしています。

理由としては、ルーティングの自動生成などと同じく、それぞれのファイルの本質的な記述のみに専念することができ、また、 namespaced オプションのつけ忘れなどのケアレスミスも防ぐことができるためです。

### モジュールモードでの Vuex の利用

実際にモジュールモードにおいての Vuex の利用方法をご紹介します。

## &lt;no-ssr&gt; と process.browser

これまでご紹介してきた機能はいずれも Vue には不足しており、 Nuxt が課題を解決している機能となりましたが、これだけは別枠となります。

Nuxt は、その思想と性質の都合上、 SSR が強く意識されており、基本的にはブラウザでもサーバーでもどちらでも動くようなアプリケーションの開発が前提となっております。

しかしながら、先程の Google Analytics プラグインの作成でもご紹介したように、実際には window オブジェクトのアクセスなどで、ブラウザでしか動作しないコードが必要となる場合はそれなりに存在します。

こういったシチュエーションにおいて、プラグインなどは明示的に SSR 時にオフにする機能がありますが、 Vue コンポーネントおよびその中のロジックにおいては、少し違った形で実装されています。

Vueコンポーネント向けの &lt;no-ssr&gt; タグおよびその内部ロジック向けの process.browser についてご紹介します。

### &lt;no-ssr&gt; コンポーネント

このコンポーネントはその名の通り、&lt;no-ssr&gt; 内の HTML については全てについてレンダリングをスキップし、代替テキストを表示するためのコンポーネントとなります。

このコンポーネントは、 Nuxt 本体のものではなく、 egoist/vue-no-ssr を移植したものとなりますが、 Nuxt 側でグローバルに定義されているため、別途 import の必要なく利用が可能となります。

どうしても SSR をさせたくない物がある場合は、こちらを利用すると良いでしょう。

```html:no-ssrの利用例.vue
<template>
  <no-ssr>
    content
  </no-ssr>
</template>
```

### process.browser

process.browser は、 Node.js の process オブジェクトに拡張された boolean 型の変数となります。

これは、 SSR 実行時は false に、ブラウザ上での、 SPA としての動作時は true にと、自動で
 Nuxt が切り替えてくれる変数となります。

window オブジェクトを参照する際は、該当処理の前に process.browser の値を if で評価してやるなどによって、 SSR 時にエラーになることなく該当オブジェクトへの参照が可能となります。

基本的にはコンポーネント全体を process.browser で切り分けたい場合は &lt;no-ssr&gt; で問題ありませんが、レイアウトの計算などで一部だけ window オブジェクトを利用している場合は、こちらを利用すると良いでしょう。

## エラーページのカスタマイズ

最後に、開発が完了した頃にあとから必要となりがちな、エラーページのカスタマイズについてご紹介いたします。
