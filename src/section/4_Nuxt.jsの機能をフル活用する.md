# Nuxt の機能をフル活用する

前セクションにて、 Nuxt の基本的な機能と使い方についてご紹介しましたが、ここからはより実践的な Nuxt の機能を機能単位で一つずつご紹介していきます。

いずれも Vue 単体の開発では頭を悩ませることの多い課題であり、その課題への解決策を
 Nuxt が提示してくれているポイントとなりますので、存分にご活用して効率的なアプリケーション開発に役立てていただけると幸いです。

## layouts によるレイアウトの共通化

Nuxt には、ページごとの共通レイアウトを、Vueコンポーネントとして再利用するレイアウト機能が実装されています。

例えば、「基本的にはナビゲーションやヘッダーを共通化して表示したいけれど、ルートコンポーネント上に定義してしまうとログイン画面やトップページなど、表示したくないページで表示されてしまい不便。とはいえその解決のために下手に `v-if` で分岐すると次はルートのコンポーネントが汚れてしまう。」

といった、共通化したいモチベーションと共通化した場合に管理コストが増大するという問題が共存している場合には、 layouts を利用することで解決が可能です。

その他にも、投稿型システムの単一投稿の表示ページにおいて、レイアウト側で極力UIを定義しておくことで、投稿の本体をクリーンに保ち、単一投稿の表示UIを効率的に使いまわすなど、「特定のUIの形式をテンプレート化したい」という時にも利用でき、非常に便利な機能となります。

### シンプルなレイアウトの利用

〜〜〜
WIP
〜〜〜

### レイアウトファイル設計のベストプラクティス

一見非常なレイアウトシステムですが、多少クセがあるため、最後にラクにレイアウトを管理するためのオススメの方法をご紹介いたします。

starter テンプレートを初期化した時など、基本的にはdefault.vueとトップページから編集をはじめることが多いかと思いますが、基本的にトップページはLPであったり、ダッシュボードのサマリーページであったり、他のページとは大きく異なるデザインを適用することがほとんどです。

そして、default.vueをトップページ用に、それぞれの個別のページをsingle.vueなどとした場合、全てのページコンポーネントに対して `layout: 'single'` を指定する必要があり、適用忘れなどのミスの原因となります。

こうした時、発想を転換して、default.vueはアプリケーション全体で使われるレイアウトとし、トップページなどを home.vue などのレイアウトファイルに逃してやりましょう。

こうすることで、トップページは専用の home.vue により完全に隔離された上で、煩雑なレイアウトの設定も行う必要がなくなることでしょう。

## middlewareを利用したルーティング結果の改竄

次はミドルウェアです。
サーバーサイドのプログラミングを行ったことがあるかたにはおなじみの、request / responseオブジェクトに対して、そのルーティングの実処理の前後に割り込み、request / responseオブジェクトを改ざんすることができる機能となります。

例えば、この機能を利用することで、「Cookieに格納された認証トークンを確認した上で、正しい認証トークンの場合はVuexのストアに認証情報を追加する機能」や、「日本人が英語ページにきた際に自動で日本語ページへとリダイレクトをする機能」など、Webアプリケーションの開発で頻繁に利用される割り込みを、非常に簡単に実装することが可能となります。

特に、Nuxt.jsでは、request / responseオブジェクトの改ざんだけでなく、上述の通りVuexストアへのアクセスや、302リダイレクトの発行などが可能となっているため、非常に柔軟に利用することが可能となっています。

ここではmiddlewareを利用した、簡単なリダイレクトシステムを実装してみましょう。

### 最低限のミドルウェア雛形の作成

〜〜〜
WIP
〜〜〜

### ミドルウェアでのデータ取得とリダイレクト

〜〜〜
WIP
〜〜〜

### ミドルウェアの注意点

最後に、非常に強力な機能であるミドルウェアですが、一つ大きな欠点を抱えているためご紹介いたします。

ミドルウェアは、requestオブジェクトへのアクセスを必要とする場合があるという都合上、SPAモードでは動作しません。SSRモードにおいても、初期アクセス時のみ有効な機能となっており、SPAモードに一旦移行してしまった場合、ミドルウェアは機能を失います。

また、勿論ですが、ミドルウェアの実行はサーバー側の作業の一環となりますので、外部APIへのフェッチなどを行う際は、レスポンス速度に多少なりとも影響があることを十分に理解した上で利用すると良いでしょう。私としては、ミドルウェアの利用はルーティングの認証機能の実装程度に留めておくことを強くオススメします。

## plugin機能によるグローバルな機能拡張

ミドルウェアと似ているようで大きく違う、プラグイン機能についてもご紹介いたします。
このプラグイン機能は、初期アクセス時に自動で読み出され、特定の処理を行うという

### プラグインの使いどころ

### Google Analyticsのプラグイン化

### プラグインの上手な利用方法

## Vuexのモジュールモードを活用したオートローディング

次に、 Vuex のオートローディングについて説明いたします。
前章でも軽く説明しましたが、ここではより深く、実践的な利用方法についてご紹介いたします。

### Vuexストアへのアクセスの二つのモード

Nuxt の Vuex ストアには **クラシックモード** と **モジュールモード**  という二つのモードがあります。以下に簡単に違いについて説明します。

クラシックモードは、単一の State のみをもつ大きな Vuex ストアをベースに、もしモジュールが必要であれば適宜手動で追加していく、通常の Vue 開発に近いモードです。

モジュールモードは、 Nuxt の store ディレクトリ内にファイルを作成してゆき、 Vuex ストアインスタンスではなく、 state や mutation 、 action などをそれぞれ別にエクスポートすることで、 Nuxt が自動で全てのファイルを名前空間付きのモジュールとして解釈し、 Vuex ストアインスタンスにまとめてくれるモードとなります。

筆者としては、数ページ規模の小規模アプリケーションまではクラシックモードで十分ですが、そういったもの以外ではモジュールモードの利用をオススメしています。

理由としては、ルーティングの自動生成などと同じく、それぞれのファイルの本質的な記述のみに専念することができ、また、 namespaced オプションのつけ忘れなどのケアレスミスも防ぐことができるためです。

### モジュールモードでの Vuex の利用

実際にモジュールモードにおいての Vuex の利用方法をご紹介します。

## no-ssrとprocess.browser

これまでご紹介してきた機能はいずれもVue.jsには不足しており、Nuxt.jsが課題を解決している機能となりましたが、これだけは別枠となります。

Nuxt.jsは、その思想と性質の都合上、SSRが強く意識されており、基本的にはブラウザでもサーバーでもどちらでも動くようなアプリケーションの開発が前提となっております。

しかしながら、先程のGoogle Analyticsプラグインの作成でもご紹介したように、実際にはwindowオブジェクトのアクセスなどで、ブラウザでしか動作しないコードが必要となる場合はそれなりに存在します。

こういったシチュエーションにおいて、プラグインなどは明示的にSSR時にオフにする機能がありますが、Vueコンポーネントおよびその中のロジックにおいては、少し違った形で実装されています。

Vueコンポーネント向けの &lt;no-ssr&gt; タグおよびその内部ロジック向けの process.browserについてご紹介します。

### &lt;no-ssr&gt; コンポーネント

このコンポーネントはその名の通り、&lt;no-ssr&gt; 内のHTMLについては全てについてレンダリングをスキップし、代替テキストを表示するためのコンポーネントとなります。

このコンポーネントは、Nuxt.js本体のものではなく、 egoist/vue-no-ssr を移植したものとなりますが、Nuxt.js側でグローバルに定義されているため、別途importの必要なく利用が可能となります。

どうしてもSSRをさせたくない物がある場合は、こちらを利用すると良いでしょう。

```html:no-ssrの利用例
<template>
  <no-ssr>
    content
  </no-ssr>
</template>
```

### process.browser

process.browser は、 Node.js の process オブジェクトに拡張された boolean 型の変数となります。

これは、 SSR 実行時は false に、ブラウザ上での、 SPA としての動作時は true にと、自動で
 Nuxt が切り替えてくれる変数となります。

window オブジェクトを参照する際は、該当処理の前に process.browser の値を if で評価してやるなどによって、 SSR 時にエラーになることなく該当オブジェクトへの参照が可能となります。

## エラーページのカスタマイズ

最後に、開発が完了した頃にあとから必要となりがちな、エラーページのカスタマイズについてご紹介いたします。
